import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# -----------------------------------------------------
# ЛОГИРОВАНИЕ
# -----------------------------------------------------
def log(msg):
    print(f"[LOG] {msg}")

# -----------------------------------------------------
# ПАРАМЕТРЫ СИСТЕМЫ
# -----------------------------------------------------
g = 9.81          # ускорение свободного падения
l = 1.0           # длина стержня
a = 0.1           # амплитуда вертикальных колебаний подвеса
nu = 50.0         # вынуждающая частота (ν » ω0)
omega0 = np.sqrt(g/l)

log("=== МОДЕЛЬ МАЯТНИКА КАПИЦЫ ===")
log(f"Собственная частота ω0 = {omega0:.3f}")
log(f"Частота вибраций ν = {nu:.1f}   (ν >> ω0)")

# -----------------------------------------------------
# 1. ОБЫЧНЫЙ МАЯТНИК — дифференциальное уравнение
# -----------------------------------------------------
def pendulum_eq(t, y):
    phi, dphi = y
    ddphi = -(g/l) * np.sin(phi)
    return [dphi, ddphi]

# -----------------------------------------------------
# 2. МАЯТНИК КАПИЦЫ — УРАВНЕНИЕ КАПИЦЫ
# -----------------------------------------------------
def kapitza_eq(t, y):
    phi, dphi = y
    ddphi = -(a * nu**2 * np.cos(nu*t) + g) * np.sin(phi) / l
    return [dphi, ddphi]

# -----------------------------------------------------
# ИНТЕГРИРОВАНИЕ
# -----------------------------------------------------
T = 10
dt = 0.0005
t = np.arange(0, T, dt)

log("Запуск численного интегрирования...")

# Обычный маятник
sol_p = solve_ivp(pendulum_eq, [0, T], [0.2, 0], t_eval=t)

# Маятник Капицы
sol_k = solve_ivp(kapitza_eq, [0, T], [0.2, 0], t_eval=t)

phi_p = sol_p.y[0]
phi_k = sol_k.y[0]
dphi_k = sol_k.y[1]

log("Интегрирование завершено")

# -----------------------------------------------------
# ЭФФЕКТИВНЫЙ ПОТЕНЦИАЛ КАПИЦЫ
# -----------------------------------------------------
phi_grid = np.linspace(-np.pi, np.pi, 400)
V_eff = m = 1.0 # масса нам не важна, берем m=1

V_eff = g*l*np.cos(phi_grid) + (a**2 * nu**2 / 4) * np.sin(phi_grid)**2

# -----------------------------------------------------
# ТРАЕКТОРИЯ МАЯТНИКА (x,y)
# -----------------------------------------------------
x = l * np.sin(phi_k)
y = -l * np.cos(phi_k)

# -----------------------------------------------------
# ГРАФИКИ
# -----------------------------------------------------
fig, ax = plt.subplots(3, 1, figsize=(12, 14))

# --- обычный маятник ---
ax[0].plot(t, phi_p)
ax[0].set_title("Обычный маятник — φ(t)")
ax[0].set_xlabel("t")
ax[0].set_ylabel("φ")

# --- маятник Капицы ---
ax[1].plot(t, phi_k, color="orange")
ax[1].set_title("Маятник Капицы — φ(t)   (ν >> ω0)")
ax[1].set_xlabel("t")
ax[1].set_ylabel("φ")

# --- эффективный потенциал ---
ax[2].plot(phi_grid, V_eff, color="green")
ax[2].set_title("Эффективный потенциал V_eff(φ)")
ax[2].set_xlabel("φ")
ax[2].set_ylabel("V_eff")

plt.tight_layout()
plt.show()

# -----------------------------------------------------
# ДОПОЛНИТЕЛЬНЫЕ ГРАФИКИ: траектория + zoom
# -----------------------------------------------------
fig2, ax2 = plt.subplots(1, 2, figsize=(14, 5))

# ТРАЕКТОРИЯ
ax2[0].plot(x, y)
ax2[0].set_title("Траектория маятника (x,y)")
ax2[0].set_xlabel("x")
ax2[0].set_ylabel("y")

# Увеличенный участок φ(t)
ax2[1].plot(t[:4000], phi_k[:4000])
ax2[1].set_title("φ(t) — увеличенный участок")
ax2[1].set_xlabel("t")
ax2[1].set_ylabel("φ")

plt.tight_layout()
plt.show()

log("=== РАСЧЁТ ЗАВЕРШЕН ===")
log(f"Амплитуда колебаний маятника Капицы ≈ {np.max(phi_k):.3f} рад")
